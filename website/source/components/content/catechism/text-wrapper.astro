---
import { Language, TextWrapper as TextWrapperType } from '@catechism-types';

import CrossReferenceTrigger from './cross-reference-trigger.astro';
import PlainText from './plain-text.astro';
import ReferenceCollection from './reference-collection.astro';

interface Props {
    textWrapper: TextWrapperType;
    language: Language;
}

const { textWrapper, language } = Astro.props;
---

<span>
    {/* gutter cross-references */}
    <span
        class="hide-cross-references:hidden max-md:hidden absolute right-2 text-end"
        data-pagefind-ignore="all"
    >
        {
            textWrapper.paragraphReferences.map((reference, index, allReferences) => {
                const hasProceedingTrigger = index < allReferences.length - 1;
                const separator = hasProceedingTrigger ? ', ' : '';

                return (
                <CrossReferenceTrigger {reference} {language}>
                    <span
                        class="relative isolate font-sans font-medium text-2xs text-stone-500 tracking-wide cursor-pointer transition-colors dark:text-stone-400"
                    >
                        <span
                            class:list={[
                                'peer absolute -inset-4',
                                'rounded-full transition-colors',
                                'hover:bg-stone-150 active:bg-stone-200',
                                'dark:hover:bg-neutral-700 dark:active:bg-neutral-750',
                            ]}
                        ></span>
                        <span
                            inert
                            class="relative z-10 transition-colors dark:peer-hover:text-neutral-300 dark:peer-active:text-neutral-300"
                        >
                            {reference.toString()}{separator}
                        </span>
                    </span>
                </CrossReferenceTrigger>
            );
            })
        }
    </span>

    <span>
        {/* main content */}
        {textWrapper.mainContent.map((text, index) => <PlainText {text} lastFragment={index === textWrapper.mainContent.length - 1} />)}

        {/* external references */}
        {
            textWrapper.referenceCollection?.references.length > 0 && (
                <ReferenceCollection {language} referenceCollection={textWrapper.referenceCollection} />
            )
        }
    </span>
</span>
